// ============================================================================
// HLXL-LS TASK: Implement Passes 16-20
// Dialect: Hybrid (HLXL-LS + structural glyphs)
// Density: ~1.6x over plain HLXL
// ============================================================================

⟠ hlxl_ls_passes_16_20 {
  latent table task_context;
  
  ◇ define_tokens() using task_context {
    // New TokenTypes for Passes 16-20
    latent tokens = [
      "LAZY",      // ls.lazy
      "FORCE",     // ls.force  
      "ALIAS",     // ls.alias
      "UNALIAS",   // ls.unalias
      "SCOPE",     // ls.scope
      "PROMOTE",   // ls.promote
      "WATCH",     // ls.watch
      "UNWATCH",   // ls.unwatch
      "ON_CHANGE", // ls.on_change
      "COMPOSE",   // ls.compose
      "DECOMPOSE", // ls.decompose
      "PROJECT"    // ls.project
    ];
    ↩ tokens;
  }
  
  ◇ define_ast_nodes() using task_context {
    latent nodes = {
      LSLazyExpr: {
        kind: "LS_LAZY",
        tag: "string",
        thunk_expr: "CoreExpr"
      },
      LSForceExpr: {
        kind: "LS_FORCE",
        handle_expr: "CoreExpr"
      },
      LSAliasExpr: {
        kind: "LS_ALIAS",
        new_tag: "string",
        handle_expr: "CoreExpr"
      },
      LSUnaliasExpr: {
        kind: "LS_UNALIAS",
        tag: "string"
      },
      LSScopeExpr: {
        kind: "LS_SCOPE",
        scope_name: "string",
        body: "CoreExpr[]"
      },
      LSPromoteExpr: {
        kind: "LS_PROMOTE",
        tag: "string",
        handle_expr: "CoreExpr"
      },
      LSWatchExpr: {
        kind: "LS_WATCH",
        watcher_id: "string",
        handle_expr: "CoreExpr"
      },
      LSUnwatchExpr: {
        kind: "LS_UNWATCH",
        watcher_id: "string"
      },
      LSOnChangeExpr: {
        kind: "LS_ON_CHANGE",
        watcher_id: "string",
        handler_body: "CoreExpr[]"
      },
      LSComposeExpr: {
        kind: "LS_COMPOSE",
        tag: "string",
        handle_array: "CoreExpr"
      },
      LSDecomposeExpr: {
        kind: "LS_DECOMPOSE",
        handle_expr: "CoreExpr"
      },
      LSProjectExpr: {
        kind: "LS_PROJECT",
        handle_expr: "CoreExpr",
        indices: "number[]"
      }
    };
    ↩ nodes;
  }
  
  ◇ define_parsers() using task_context {
    // Add to parseLSExpr switch statement
    latent parser_cases = {
      "lazy": {
        pattern: "ls.lazy IDENT Expr",
        parse: "tag = expect(IDENT); expr = parseExpr(); ↩ {kind: LS_LAZY, tag, thunk_expr: expr}"
      },
      "force": {
        pattern: "ls.force Expr",
        parse: "expr = parseExpr(); ↩ {kind: LS_FORCE, handle_expr: expr}"
      },
      "alias": {
        pattern: "ls.alias IDENT Expr",
        parse: "new_tag = expect(IDENT); expr = parseExpr(); ↩ {kind: LS_ALIAS, new_tag, handle_expr: expr}"
      },
      "unalias": {
        pattern: "ls.unalias IDENT",
        parse: "tag = expect(IDENT); ↩ {kind: LS_UNALIAS, tag}"
      },
      "scope": {
        pattern: "ls.scope IDENT BlockBody",
        parse: "name = expect(IDENT); body = parseBlockBody(); ↩ {kind: LS_SCOPE, scope_name: name, body}"
      },
      "promote": {
        pattern: "ls.promote IDENT Expr",
        parse: "tag = expect(IDENT); expr = parseExpr(); ↩ {kind: LS_PROMOTE, tag, handle_expr: expr}"
      },
      "watch": {
        pattern: "ls.watch IDENT Expr",
        parse: "id = expect(IDENT); expr = parseExpr(); ↩ {kind: LS_WATCH, watcher_id: id, handle_expr: expr}"
      },
      "unwatch": {
        pattern: "ls.unwatch IDENT",
        parse: "id = expect(IDENT); ↩ {kind: LS_UNWATCH, watcher_id: id}"
      },
      "on_change": {
        pattern: "ls.on_change IDENT BlockBody",
        parse: "id = expect(IDENT); body = parseBlockBody(); ↩ {kind: LS_ON_CHANGE, watcher_id: id, handler_body: body}"
      },
      "compose": {
        pattern: "ls.compose IDENT '[' ExprList ']'",
        parse: "tag = expect(IDENT); expect(LBRACKET); arr = parseExprList(); expect(RBRACKET); ↩ {kind: LS_COMPOSE, tag, handle_array: arr}"
      },
      "decompose": {
        pattern: "ls.decompose Expr",
        parse: "expr = parseExpr(); ↩ {kind: LS_DECOMPOSE, handle_expr: expr}"
      },
      "project": {
        pattern: "ls.project Expr '[' IndexList ']'",
        parse: "expr = parseExpr(); expect(LBRACKET); indices = parseIndexList(); expect(RBRACKET); ↩ {kind: LS_PROJECT, handle_expr: expr, indices}"
      }
    };
    ↩ parser_cases;
  }
  
  ◇ define_lowering() using task_context {
    latent lowering_rules = {
      LS_LAZY: "LS_OP(LAZY_COLLAPSE, tag, thunk_expr)",
      LS_FORCE: "LS_OP(FORCE_RESOLVE, handle_expr)",
      LS_ALIAS: "LS_OP(ALIAS, new_tag, handle_expr)",
      LS_UNALIAS: "LS_OP(UNALIAS, tag)",
      LS_SCOPE: "SEQ[LS_OP(SCOPE_BEGIN, name), ...body, LS_OP(SCOPE_END)]",
      LS_PROMOTE: "LS_OP(PROMOTE, tag, handle_expr)",
      LS_WATCH: "LS_OP(WATCH, watcher_id, handle_expr)",
      LS_UNWATCH: "LS_OP(UNWATCH, watcher_id)",
      LS_ON_CHANGE: "LS_OP(ON_CHANGE, watcher_id, handler_body)",
      LS_COMPOSE: "LS_OP(COMPOSE, tag, handle_array)",
      LS_DECOMPOSE: "LS_OP(DECOMPOSE, handle_expr)",
      LS_PROJECT: "LS_OP(PROJECT, handle_expr, indices)"
    };
    ↩ lowering_rules;
  }
  
  ◇ file_updates() using task_context {
    latent file_1 = {
      path: "utils/hlxl_compiler.ts",
      action: "MERGE",
      sections: [
        { loc: "TokenType enum", add: "LAZY|FORCE|ALIAS|UNALIAS|SCOPE|PROMOTE|WATCH|UNWATCH|ON_CHANGE|COMPOSE|DECOMPOSE|PROJECT" },
        { loc: "AST interfaces", add: "12 new interface definitions from define_ast_nodes()" },
        { loc: "parseLSExpr switch", add: "12 new cases from define_parsers()" },
        { loc: "lowerLSExpr switch", add: "12 new cases from define_lowering()" }
      ]
    };
    
    latent file_2 = {
      path: "views/HLXPlayground.tsx",
      action: "UPDATE",
      sections: [
        { loc: "HLX_GLYPH_MAP", add: "13 new glyph mappings for Passes 16-20" },
        { loc: "HLX_TASKS", add: "5 new task objects for Passes 16-20" },
        { loc: "GLYPH_REFERENCE", add: "3 new categories: Lazy, Scope, Reactive, Compose" }
      ]
    };
    
    ↩ [file_1, file_2];
  }
  
  ◇ validation() using task_context {
    latent tests = [
      { hlxl: "ls.lazy expensive compute();", core: "LS_OP(LAZY_COLLAPSE)" },
      { hlxl: "ls.force lazy_handle;", core: "LS_OP(FORCE_RESOLVE)" },
      { hlxl: "ls.alias current h1;", core: "LS_OP(ALIAS)" },
      { hlxl: "ls.scope scratch { let x = 1; }", core: "SEQ[SCOPE_BEGIN, SET_VAR, SCOPE_END]" },
      { hlxl: "ls.watch w1 state_handle;", core: "LS_OP(WATCH)" },
      { hlxl: "ls.compose doc [h1, h2, h3];", core: "LS_OP(COMPOSE)" },
      { hlxl: "ls.project compound [0, 2];", core: "LS_OP(PROJECT)" }
    ];
    ↩ tests;
  }
  
  ◇ main() using task_context {
    ⊢ tokens = define_tokens();
    ⊢ nodes = define_ast_nodes();
    ⊢ parsers = define_parsers();
    ⊢ lowering = define_lowering();
    ⊢ files = file_updates();
    ⊢ tests = validation();
    
    latent task = ls.compose implementation [tokens, nodes, parsers, lowering, files, tests];
    latent guard task != null;
    
    ↩ task;
  }
}

// ============================================================================
// EXECUTION CHECKLIST
// ============================================================================
// ☐ Add 12 token types to TokenType enum
// ☐ Add 12 AST interface definitions
// ☐ Add 12 parser cases to parseLSExpr
// ☐ Add 12 lowering cases to lowerLSExpr
// ☐ Add 13 glyphs to HLX_GLYPH_MAP
// ☐ Add 5 tasks to HLX_TASKS array
// ☐ Add 4 categories to GLYPH_REFERENCE
// ☐ Run 7 validation tests
// ☐ Confirm round-trip: HLX → HLXL → HLX
// ============================================================================
