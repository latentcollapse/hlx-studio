{
  "codex": {
    "meta": {
      "title": "HLX Unified Codex",
      "version": "1.0.0",
      "status": "CANONICAL_ROOT",
      "generated_at": "2025-12-13T18:00:00Z",
      "encoding": "UTF-8",
      "hash_algo": "BLAKE3",
      "integrity_check": "‚ü† ‚óá ‚ö≥ ‚öØ üúä üúÅ üúÇ üúÉ üúÑ üúá ‚üÅ üúã",
      "architecture_class": "TRANSPORT",
      "architecture_statement": "HLX specifies canonical encoding, ordering, and transfer of values. It does not define semantic meaning or execution behavior.",
      "purpose": "Didactic injection of the HLX Language Family into LLM context. This file is the single source of truth for bootstrapping HLX capability.",
      "terminology_canon": "hlx_terminology_canon.json",
      "density_profiles": [
        "hlx_density_profile.json"
      ]
    },
    "1_axioms": {
      "description": "The inviolable truths governing the Helix architecture.",
      "axioms": [
        {
          "id": "A1",
          "name": "DETERMINISM",
          "rule": "The same input code must ALWAYS produce the same Latent Collapse (LC) stream."
        },
        {
          "id": "A2",
          "name": "REVERSIBILITY",
          "rule": "Any value compressed into a Handle (‚ö≥) can be resolved (‚öØ) back to its exact original state."
        },
        {
          "id": "A3",
          "name": "BIJECTION",
          "rule": "Track A (Lite/ASCII) and Track B (Runic/Glyph) are mathematically isomorphic. They map 1:1."
        },
        {
          "id": "A4",
          "name": "UNIVERSAL_VALUE",
          "rule": "All tracks lower to the HLX-Lite Value System (Contracts 1-5) before encoding."
        }
      ]
    },
    "contract_registry_ref": {
      "file": "hlx_contracts.json",
      "policy": {
        "unknown_contracts": "ALLOWED",
        "validation_level": "STRUCTURAL_ONLY",
        "semantic_interpretation": "EXTERNAL",
        "execution": "OUT_OF_SCOPE"
      },
      "note": "Contract IDs may be unknown. Unknown ‚â† invalid. Validation is structural only."
    },
    "2_architecture": {
      "description": "The Dual-Track Architecture. Two surface languages, one runtime.",
      "tracks": {
        "track_a_lite": {
          "name": "HLX-Lite (Engineering)",
          "audience": "Humans, IDEs, Git, CI/CD",
          "format": "ASCII Text",
          "pipeline": "HLXL (Source) -> HLXL-LS (Latent Ops) -> HLX-Lite Value -> LC Stream"
        },
        "track_b_runic": {
          "name": "HLX-Runic (Native)",
          "audience": "LLMs, Context Windows, Vector Stores",
          "format": "Unicode Glyphs",
          "pipeline": "HLX (Source) -> HLX-LS (Latent Ops) -> HLX-Lite Value -> LC Stream"
        }
      },
      "convergence": {
        "point": "HLX-Lite Value System",
        "wire": "LC (Latent Collapse) Stream"
      }
    },
    "3_foundation_values": {
      "description": "The atomic type system underlying all HLX languages. It defines HOW data is structured.",
      "primitive_types": {
        "NULL": {
          "id": 0,
          "lc_marker": "Implied by Contract"
        },
        "BOOL": {
          "id": 1,
          "values": [
            "true",
            "false"
          ]
        },
        "INT": {
          "id": 2,
          "format": "Signed 64-bit LEB128"
        },
        "FLOAT": {
          "id": 3,
          "format": "IEEE 754 Double"
        },
        "TEXT": {
          "id": 4,
          "format": "UTF-8 String"
        },
        "BYTES": {
          "id": 5,
          "format": "Raw Byte Sequence"
        },
        "ARRAY": {
          "id": 6,
          "format": "Ordered List"
        },
        "OBJECT": {
          "id": 7,
          "format": "Typed Map (ContractID + Sorted Fields)"
        }
      },
      "field_notation": {
        "syntax": "@N",
        "description": "@N denotes zero-based field index N within a contract object.",
        "rule": "Fields MUST be encoded in ascending index order in LC-B. Violations raise E_FIELD_ORDER."
      }
    },
    "4_transliteration": {
      "description": "Mandatory ASCII transliteration table for all canonical glyphs.",
      "table": {
        "‚ü†": "program",
        "‚óá": "block",
        "‚ä¢": "let",
        "‚ä°": "local",
        "‚Ü©": "return",
        "‚ùì": "if",
        "‚ùó": "else",
        "‚ü≥": "while",
        "‚ü≤": "for",
        "‚ö≥": "ls.collapse",
        "‚öØ": "ls.resolve",
        "‚ö∂": "ls.snapshot",
        "‚öø": "ls.transaction",
        "‚ñ∑": "|>",
        "‚üÅ": "&h_"
      }
    },
    "5_latent_collapse": {
      "name": "LC (Latent Collapse)",
      "description": "The universal wire format. Defined in two modes as per SD9.",
      "dual_mode": true,
      "lc_t_text": {
        "status": "PEDAGOGICAL",
        "description": "Human-readable projection for LLMs and debugging.",
        "markers": {
          "üúä": "OBJECT_START",
          "üúÅ": "FIELD_START",
          "üúÇ": "OBJECT_END",
          "üúÉ": "ARRAY_START",
          "üúÑ": "ARRAY_END",
          "üúá": "HANDLE_REF",
          "üúã": "STREAM_END"
        }
      },
      "lc_b_binary": {
        "status": "CANONICAL",
        "description": "Authoritative binary form for hashing and storage (v2).",
        "tags": {
          "0x01": "INT (Signed LEB128)",
          "0x02": "FLOAT (IEEE754 Big-Endian)",
          "0x03": "TEXT (LEB128 Len + UTF-8)",
          "0x04": "BYTES (LEB128 Len + Raw)",
          "0x05": "ARR_START",
          "0x06": "ARR_END",
          "0x07": "OBJ_START (LEB128 ContractID)",
          "0x08": "OBJ_END",
          "0x09": "HANDLE_REF (LEB128 Len + ASCII)"
        },
        "object_rule": "Fields encoded as <field_idx_leb128><VALUE>. Must be sorted by index."
      },
      "lc_12_envelope_spec": {
        "merkle_spec": "MERKLE SPEC (FANOUT 16, CANONICAL): Let chunks be ordered by index i = 0..N-1. Leaf hash: H_leaf[i] = BLAKE3(chunk_bytes[i]). Group leaves in order into nodes of up to 16 children. INTERNAL NODE (CANONICAL): - Let child_count be the number of children in this node, where 1 ‚â§ child_count ‚â§ 16. - Let child_hashes be the ordered list of child hashes for this node. - Compute the internal node hash as: H_node = BLAKE3( byte(child_count) || concat(child_hash_0 || child_hash_1 || ... || child_hash_(child_count-1)) ) - If child_count < 16, PAD with 32-byte zero hashes before hashing. - child_hash_i MUST be the 32-byte BLAKE3 digest of the corresponding child. - Children MUST be concatenated in strictly increasing child index order. - Root hash = top node hash. VERIFICATION RULE: - A receiver MUST recompute leaf hashes, rebuild the tree using this exact rule, and compare the resulting payload_root to the manifest. - Any mismatch is fatal (E_ENV_PAYLOAD_HASH_MISMATCH).",
        "table_order_key": "TABLE ORDER KEY (CANONICAL): Normalize handle string with Unicode NFC. Lowercase using Unicode simple case-folding. Strip exactly one leading literal \"&h_\" prefix if present; strip nothing else. order_key = UTF-8 bytes of resulting string. Sort ascending lexicographic by order_key bytes. - Case folding MUST use Unicode 15.0 simple case folding as defined in Unicode Character Database file CaseFolding.txt. Non-ASCII handles raise E_HANDLE_INVALID."
      }
    }
  },
  "contracts": {
    "version": "1.0.0",
    "architecture_class": "TRANSPORT",
    "policy": {
      "unknown_contracts": "ALLOWED",
      "validation_level": "STRUCTURAL_ONLY",
      "semantic_interpretation": "EXTERNAL",
      "execution": "OUT_OF_SCOPE"
    },
    "primitive_contracts": {
      "1": {
        "name": "NULL",
        "kind": "PRIMITIVE"
      },
      "2": {
        "name": "BOOL",
        "kind": "PRIMITIVE"
      },
      "3": {
        "name": "INT",
        "kind": "PRIMITIVE"
      },
      "4": {
        "name": "FLOAT",
        "kind": "PRIMITIVE"
      },
      "5": {
        "name": "TEXT",
        "kind": "PRIMITIVE"
      },
      "6": {
        "name": "BYTES",
        "kind": "PRIMITIVE"
      },
      "7": {
        "name": "ARR_OBJ_FRAMING",
        "kind": "MECHANICAL"
      }
    },
    "known_contracts": {}
  },
  "conformance": {
    "meta": {
      "name": "HLX Runtime Conformance Spec",
      "version": "1.0.0",
      "capsule_version": "v1.0.0",
      "status": "CANONICAL_ROOT",
      "generated_at": "2025-12-13T18:00:00Z",
      "encoding": "UTF-8",
      "language_codex_ref": "hlx_codex.json",
      "codex_hash": "sha256:602e2baf7ec46f60a321dbf96f47c470b40ead76321a76f5e683e4ec4129ce51",
      "integrity_check": "‚ü† ‚óá ‚ö≥ ‚öØ üúä üúÅ üúÇ üúÉ üúÑ üúá ‚üÅ üúã"
    },
    "1_scope_and_roles": {
      "roles": {
        "LLM": {
          "analogy": "CPU / Orchestrator",
          "responsibility": "Generating intent (HLX/HLXL), formulating logic, requesting operations.",
          "restriction": "MUST NOT hallucinate handle contents. MUST NOT attempt to parse raw LC streams manually. MUST NOT compute authoritative hashes."
        },
        "Runtime": {
          "analogy": "RAM / Disk / Physics Engine",
          "responsibility": "Storing values (CAS), resolving handles, enforcing invariants, validating contracts.",
          "authority": "Absolute source of truth for data integrity and state."
        }
      }
    },
    "2_core_data_model": {
      "handles": {
        "format_ascii": "&h_<tag>_<id>",
        "format_runic": "‚üÅ<tag><subscript_id>",
        "subscript_rule": "ASCII digits 0-9 map to Unicode subscripts ‚ÇÄ-‚Çâ.",
        "resolution": "Handles are opaque pointers to immutable content-addressed blobs."
      },
      "tables": {
        "definition": "A Latent Table is a scoped namespace mapping Handles to canonical HLX-Lite Values."
      }
    },
    "3_cas_rules": {
      "table_order_key": "TABLE ORDER KEY (CANONICAL): Normalize handle string with Unicode NFC. Lowercase using Unicode simple case-folding. Strip exactly one leading literal \"&h_\" prefix if present; strip nothing else. order_key = UTF-8 bytes of resulting string. Sort ascending lexicographic by order_key bytes. - Case folding MUST use Unicode 15.0 simple case folding as defined in Unicode Character Database file CaseFolding.txt. Non-ASCII handles raise E_HANDLE_INVALID."
    },
    "4_error_model": {
      "codes": {
        "E_LC_PARSE": "Invalid LC-T syntax",
        "E_LC_BINARY_DECODE": "Invalid LC-B encoding",
        "E_FIELD_ORDER": "Fields out of order",
        "E_CANONICALIZATION_FAIL": "Non-canonical structure (e.g., cycles)",
        "E_HANDLE_UNRESOLVED": "Handle requires runtime resolution",
        "E_HANDLE_INVALID": "Handle contains non-ASCII or invalid characters",
        "E_VALIDATION_FAIL": "Execution requested outside LLM authority",
        "E_ENV_PAYLOAD_HASH_MISMATCH": "Merkle root mismatch",
        "E_ENV_MANIFEST_INVALID": "Invalid LC_12 manifest",
        "E_CONTRACT_STRUCTURE": "Invalid contract object structure"
      }
    },
    "5_test_vectors": {
      "description": "Mandatory test cases for Runtime conformance (LC-B v2). Total Vectors: 11 Positive, 9 Negative.",
      "vectors": [
        {
          "name": "T0_Primitive_Int",
          "input": 123,
          "lc_text": "üúä2üúÅ0123üúÇ",
          "lc_binary_hex": "01 7B"
        },
        {
          "name": "T1_Primitive_String",
          "input": "hello",
          "lc_text": "üúä4üúÅ0\"hello\"üúÇ",
          "lc_binary_hex": "03 05 68 65 6C 6C 6F"
        },
        {
          "name": "T2_Simple_Object",
          "input": {
            "14": {
              "@0": 1
            }
          },
          "lc_text": "üúä14üúÅ01üúÇ",
          "lc_binary_hex": "07 0E 00 01 01 08"
        },
        {
          "name": "T3_Nested_Object",
          "input": {
            "14": {
              "@0": {
                "15": {
                  "@0": "inner"
                }
              }
            }
          },
          "lc_text": "üúä14üúÅ0üúä15üúÅ0\"inner\"üúÇüúÇ",
          "lc_binary_hex": "07 0E 00 07 0F 00 03 05 69 6E 6E 65 72 08 08"
        },
        {
          "name": "T4_Empty_Array",
          "input": [],
          "lc_text": "üúÉüúÑ",
          "lc_binary_hex": "05 06"
        },
        {
          "name": "T5_Array_Of_Ints",
          "input": [
            1,
            2,
            3
          ],
          "lc_binary_hex": "05 01 01 01 02 01 03 06"
        },
        {
          "name": "T6_Nested_Array",
          "input": [
            [
              1
            ],
            [
              2,
              3
            ]
          ],
          "lc_binary_hex": "05 05 01 01 06 05 01 02 01 03 06 06"
        },
        {
          "name": "T7_Handle_Ref",
          "input": {
            "HANDLE_REF": "&h_foo_0"
          },
          "lc_binary_hex": "09 08 26 68 5F 66 6F 6F 5F 30"
        },
        {
          "name": "T8_Multi_Field_Object",
          "input": {
            "20": {
              "@0": 1,
              "@1": "two",
              "@2": true
            }
          },
          "lc_binary_hex": "07 14 00 01 01 01 03 03 74 77 6F 02 01 08",
          "note": "Fields sorted by index."
        },
        {
          "name": "T9_Float_Value",
          "input": 3.14159,
          "lc_binary_hex": "02 40 09 21 F9 F0 1B 86 6E",
          "note": "IEEE 754 double, big-endian"
        },
        {
          "name": "T10_Empty_Object",
          "input": {
            "1": {}
          },
          "lc_binary_hex": "07 01 08"
        }
      ],
      "negative_vectors": [
        {
          "name": "N1_Whitespace_LC_T",
          "input_lc_text": "üúä 14 üúÇ",
          "expected_error": "E_LC_PARSE"
        },
        {
          "name": "N2_Invalid_Tag_LC_B",
          "input_lc_binary_hex": "FF 01",
          "expected_error": "E_LC_PARSE"
        },
        {
          "name": "N3_Cycle_Detection",
          "input_kind": "cycle_handle_ref",
          "input": {
            "self_handle": "&h_bootstrap_0",
            "value": {
              "14": {
                "@0": {
                  "HANDLE_REF": "&h_bootstrap_0"
                }
              }
            }
          },
          "expected_error": "E_CANONICALIZATION_FAIL",
          "note": "Harness MUST treat HANDLE_REF key as explicit recursive reference structure"
        },
        {
          "name": "N4_LCB_TRUNCATED",
          "input_kind": "lc_binary_hex",
          "input": "01",
          "expected_error": "E_LC_BINARY_DECODE"
        },
        {
          "name": "N5_Unsorted_Fields",
          "input": {
            "10": {
              "@2": 1,
              "@0": 2
            }
          },
          "expected_error": "E_FIELD_ORDER"
        },
        {
          "name": "N6_Overlong_LEB128",
          "input_lc_binary_hex": "07 FF FF FF FF FF FF FF FF FF 7F 08",
          "expected_error": "E_LC_BINARY_DECODE",
          "note": "Overlong LEB128 contract ID"
        },
        {
          "name": "N7_Unknown_Tag",
          "input_lc_binary_hex": "0A 01 01",
          "expected_error": "E_LC_BINARY_DECODE",
          "note": "Tag 0x0A is undefined"
        },
        {
          "name": "N8_Trailing_Bytes",
          "input_lc_binary_hex": "01 7B FF FF",
          "expected_error": "E_LC_BINARY_DECODE",
          "note": "Valid INT followed by garbage"
        },
        {
          "name": "N9_LEB128_Length_Mismatch",
          "input_lc_binary_hex": "03 05 68 65 6C",
          "expected_error": "E_LC_BINARY_DECODE",
          "note": "TEXT claims 5 bytes, only 3 provided"
        }
      ]
    }
  },
  "grammar": "(* HLX Grammar ‚Äî EBNF *)\n(* Defines surface syntax for HLX (Runic) and HLXL (ASCII) *)\n\nprogram      = '‚ü†' , identifier , '{' , { block } , '}' ;\n\nblock        = '‚óá' , identifier , '(' , [ param_list ] , ')' , '{' , { statement } , '}' ;\n\nparam_list   = identifier , { ',' , identifier } ;\n\nstatement    = let_stmt\n             | local_stmt\n             | return_stmt\n             | if_stmt\n             | while_stmt\n             | for_stmt\n             | expr_stmt ;\n\nlet_stmt     = '‚ä¢' , identifier , '=' , expr , ';' ;\nlocal_stmt   = '‚ä°' , identifier , '=' , expr , ';' ;\nreturn_stmt  = '‚Ü©' , expr , ';' ;\n\nif_stmt      = '‚ùì' , '(' , expr , ')' , '{' , { statement } , '}'\n             , [ '‚ùó' , '{' , { statement } , '}' ] ;\n\nwhile_stmt   = '‚ü≥' , '(' , expr , ')' , '{' , { statement } , '}' ;\n\nfor_stmt     = '‚ü≤' , '(' , identifier , 'in' , expr , ')' , '{' , { statement } , '}' ;\n\nexpr_stmt    = expr , ';' ;\n\nexpr         = pipe_expr ;\n\npipe_expr    = primary , { '‚ñ∑' , primary } ;\n\nprimary      = ls_op\n             | handle_ref\n             | value\n             | identifier\n             | '(' , expr , ')' ;\n\nls_op        = ls_operator , identifier , { identifier } , [ expr ] ;\n\nls_operator  = '‚ö≥' | '‚öØ' | '‚ö∂' | '‚öø' ;\n\nhandle_ref   = '‚üÅ' , identifier , [ subscript ] ;\n\nsubscript    = subscript_digit , { subscript_digit } ;\nsubscript_digit = '‚ÇÄ' | '‚ÇÅ' | '‚ÇÇ' | '‚ÇÉ' | '‚ÇÑ' | '‚ÇÖ' | '‚ÇÜ' | '‚Çá' | '‚Çà' | '‚Çâ' ;\n\nvalue        = object | array | string | number | boolean | null ;\n\nobject       = '{' , contract_id , ':' , '{' , [ field_list ] , '}' , '}' ;\ncontract_id  = integer ;\nfield_list   = field_entry , { ',' , field_entry } ;\nfield_entry  = '@' , integer , ':' , value ;\n\narray        = 'üúÉ' , { value } , 'üúÑ'\n             | '[' , [ value , { ',' , value } ] , ']' ;\n\nstring       = '\"' , { character } , '\"' ;\nnumber       = integer | float ;\ninteger      = [ '-' ] , digit , { digit } ;\nfloat        = integer , '.' , digit , { digit } ;\nboolean      = 'true' | 'false' ;\nnull         = 'null' ;\n\nidentifier   = letter , { letter | digit | '_' } ;\nletter       = 'a'..'z' | 'A'..'Z' ;\ndigit        = '0'..'9' ;\ncharacter    = (* any UTF-8 character except unescaped '\"' *) ;"
}
