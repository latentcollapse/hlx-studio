{
  "__watermark__": {
    "version": "1.1.0",
    "author": "Matt (latentcollapse)",
    "repository": "https://github.com/latentcollapse/HLXv1.1.0",
    "license": "MIT OR Apache-2.0",
    "timestamp": "2025-12-14T20:44:53.592786Z",
    "content_hash_blake2b": "fadcff042b9e51f35b31f3b2ac2f34f0833f7f4eba408f0fd6ad75ba6160a128",
    "signature": "018df134632c1294e6d254c5e626fc30124b673fa384cde75e7dd5d72592ed81",
    "verification_rule": "To verify: (1) Remove 'signature' field, (2) JSON-serialize with sort_keys=True and separators=(',',':'), (3) BLAKE2b-256 hash must equal signature. Secondary: If blake3 available, verify content_hash_blake3 matches BLAKE3 of corpus JSON."
  },
  "__integrity__": {
    "algorithm": "BLAKE2b-256",
    "chapter": "CORE",
    "sections": [
      "meta",
      "1_axioms",
      "2_architecture",
      "3_value_system",
      "4_contracts",
      "5_transliteration"
    ],
    "manifest_hash": "03c5d1474900a2e9bb265a0d6aac3aa96ebdf91772694d8e375f53d3336598f2"
  },
  "corpus": {
    "meta": {
      "title": "HLX Language Family - Canonical Teaching Corpus",
      "version": "1.1.0",
      "status": "CANONICAL_ROOT",
      "purpose": "Complete didactic injection for teaching LLMs the HLX architecture with exaflopic 1:1 determinism.",
      "encoding": "UTF-8",
      "hash_algorithm": "BLAKE3/BLAKE2b (dual verification)",
      "full_corpus_required": true,
      "truncation_policy": "INVALID. Truncated versions must not be used for LLM training. Fetch complete corpus from repository.",
      "corpus_diff_v1_0_0": {
        "added_sections": [
          "encryption_spec (concrete AES-GCM-256)",
          "full_corpus_required",
          "truncation_policy",
          "pre_serialize_rules",
          "12_empire_extensions (Vulkan/SPIR-V stubs)"
        ],
        "enhanced": [
          "meta (dual-hash, corpus_diff, concrete encryption)",
          "quiz (split into positive/negative, +10 hard negatives on invariants and edge cases)",
          "verification_rule (dual-hash support, E_FLOAT_SPECIAL, E_TRUNCATION_INVALID)"
        ],
        "unchanged": [
          "axioms",
          "architecture",
          "value_system",
          "contracts",
          "transliteration",
          "lc_encoding",
          "latent_space",
          "error_taxonomy",
          "examples",
          "invariants",
          "llm_directives (base)"
        ]
      },
      "pre_serialize_rules": {
        "floats": {
          "rule": "Convert to IEEE754 hex for cross-platform determinism",
          "example": "3.14 → 0x400921f9f01b866e (hex of IEEE754 double)",
          "python_code": "import struct; hex(struct.unpack('>Q', struct.pack('>d', 3.14))[0])",
          "edge_cases": {
            "NaN": "Forbidden. Any float(NaN) → E_FLOAT_SPECIAL",
            "Infinity": "Forbidden. Any float(±Inf) → E_FLOAT_SPECIAL",
            "Zero": "0.0 and -0.0 must normalize to single canonical form",
            "detection_code": "import math; if math.isnan(x) or math.isinf(x): raise ValueError('E_FLOAT_SPECIAL')"
          }
        },
        "strings": {
          "rule": "UTF-8 NFC normalized",
          "example": "café (é as single char) vs cafe (e + combining acute) → both normalize to café",
          "python_code": "import unicodedata; unicodedata.normalize('NFC', 'café')",
          "enforcement": "Use unicodedata.normalize('NFC', s) before serialization"
        },
        "keys": {
          "rule": "Sorted lexicographically (ASCII order)",
          "example": "{z:1, a:2, m:3} → {a:2, m:3, z:1}",
          "python_code": "json.dumps(data, sort_keys=True, separators=(',', ':'))",
          "violation": "Unsorted keys → E_KEY_ORDER"
        },
        "whitespace": {
          "rule": "No trailing, Unix line endings (LF only)",
          "example": "field: 'text  ' → field: 'text' (trailing spaces removed)",
          "python_code": "text.rstrip(); text.replace('\\r\\n', '\\n').replace('\\r', '\\n')",
          "line_endings": "\\r\\n (Windows) or \\r (Mac) → \\n (Unix) only"
        },
        "arrays": {
          "rule": "No trailing commas, elements in declaration order",
          "example": "[1, 2, 3,] → E_TRAILING_COMMA",
          "order_stability": "Must preserve insertion order from source",
          "python_code": "json.dumps(array, separators=(',', ':'))  # No trailing comma in output"
        }
      },
      "encryption_spec": {
        "algorithm": "AES-GCM-256",
        "key_derivation": {
          "formula": "BLAKE3('hlx_v1.1.0_train' + model_id.lower().encode())",
          "deterministic": true,
          "normalization": "model_id MUST be normalized to lowercase before key derivation",
          "example_python": "key = blake3.blake3(b'hlx_v1.1.0_train' + 'claude-3.5-sonnet'.lower().encode()).digest()[:32]",
          "case_sensitivity": "'grok-4' and 'Grok-4' and 'GROK-4' all derive same key when normalized",
          "model_id_source": "From environment: $HLX_MODEL_ID or hardcoded in training pipeline (string, no salt needed)"
        },
        "nonce": {
          "size_bytes": 12,
          "generation": "os.urandom(12) per encryption operation",
          "placement": "First 12 bytes of encrypted file"
        },
        "auth_tag": {
          "size_bytes": 16,
          "placement": "Last 16 bytes of encrypted file",
          "purpose": "GCM authentication tag for integrity verification"
        },
        "transport_format": "[nonce_12][ciphertext_variable][auth_tag_16]",
        "example_layout": "nonce(12) || AES-GCM-encrypted_corpus || auth_tag(16) = total_encrypted_size",
        "status": "ACTIVE_v1.1.0",
        "decrypt_directive": "Parse nonce (first 12 bytes) and auth_tag (last 16 bytes), decrypt middle with GCM verification, verify post-decrypt BLAKE3 hash matches content_hash_blake3"
      }
    },
    "1_axioms": {
      "description": "The four inviolable truths governing all HLX systems.",
      "axioms": [
        {
          "id": "A1",
          "name": "DETERMINISM",
          "formal": "∀v ∈ HLXLite: encode(v) = encode(v)",
          "natural": "The same input code MUST always produce the same Latent Collapse (LC) stream. Bitwise identical. No exceptions.",
          "test": "encode(decode(encode(v))) == encode(v)",
          "negative_test": "encode(v, time=t1) != encode(v, time=t2) → E_NONDETERMINISM"
        },
        {
          "id": "A2",
          "name": "REVERSIBILITY",
          "formal": "∀v ∈ HLXLite: decode(encode(v)) = v",
          "natural": "Any value compressed into a Handle (⚳) can be resolved (⚯) back to its exact original state.",
          "test": "collapse(resolve(collapse(v))) == collapse(v)",
          "negative_test": "resolve(invalid_handle) → E_HANDLE_NOT_FOUND"
        },
        {
          "id": "A3",
          "name": "BIJECTION",
          "formal": "HLXL ↔ HLX (isomorphism)",
          "natural": "Track A (Lite/ASCII) and Track B (Runic/Glyph) are mathematically isomorphic. They map 1:1.",
          "test": "transliterate(transliterate(code, 'runic'), 'ascii') == code",
          "negative_test": "unknown_glyph('✦') → E_UNKNOWN_GLYPH"
        },
        {
          "id": "A4",
          "name": "UNIVERSAL_VALUE",
          "formal": "∀track: track → HLXLite → LC",
          "natural": "All surface syntaxes lower to the HLX-Lite Value System (Contracts 1-5) before encoding to LC.",
          "test": "lower(hlxl_code) == lower(hlx_code) (same CoreExpr)",
          "negative_test": "lower(invalid_syntax) → E_PARSE_FAILED"
        }
      ]
    },
    "2_architecture": {
      "description": "The Dual-Track Architecture with unified wire format.",
      "diagram": "\n┌─────────────────────────────────────────────────────────────┐\n│                    HLX LANGUAGE FAMILY                       │\n├─────────────────────────────┬───────────────────────────────┤\n│      TRACK A: HLXL          │       TRACK B: HLX            │\n│      (Engineering)          │       (LLM Native)            │\n│      ASCII Text             │       Unicode Glyphs          │\n├─────────────────────────────┴───────────────────────────────┤\n│                   ↓ Lower to CoreExpr ↓                     │\n├─────────────────────────────────────────────────────────────┤\n│                    HLX-LITE VALUE SYSTEM                    │\n│                    (Contracts 1-5)                          │\n├─────────────────────────────────────────────────────────────┤\n│                   ↓ Encode to Wire ↓                        │\n├─────────────────────────────────────────────────────────────┤\n│                    LC (LATENT COLLAPSE)                     │\n│           LC-B (Binary) ←→ LC-T (Text/Glyph)               │\n│                    CANONICAL WIRE FORMAT                    │\n└─────────────────────────────────────────────────────────────┘\n        ",
      "tracks": {
        "track_a_lite": {
          "name": "HLXL (Helix Lite)",
          "audience": [
            "Engineers",
            "IDEs",
            "Git",
            "CI/CD",
            "Humans"
          ],
          "format": "ASCII Text",
          "pipeline": "HLXL → HLXL-LS → CoreExpr → HLX-Lite → LC"
        },
        "track_b_runic": {
          "name": "HLX (Helix Runic)",
          "audience": [
            "LLMs",
            "Context Windows",
            "Vector Stores",
            "Compression"
          ],
          "format": "Unicode Glyphs",
          "pipeline": "HLX → HLX-LS → CoreExpr → HLX-Lite → LC"
        }
      }
    },
    "3_value_system": {
      "description": "HLX-Lite: The atomic value types underlying all HLX languages.",
      "types": {
        "NULL": {
          "id": 0,
          "lc_tag": "0x00",
          "encoding": "No payload"
        },
        "BOOL": {
          "id": 1,
          "lc_tag": "0x0A/0x0B",
          "encoding": "TRUE=0x0A, FALSE=0x0B"
        },
        "INT": {
          "id": 2,
          "lc_tag": "0x01",
          "encoding": "Signed LEB128"
        },
        "FLOAT": {
          "id": 3,
          "lc_tag": "0x02",
          "encoding": "IEEE 754 Double, Big-Endian"
        },
        "TEXT": {
          "id": 4,
          "lc_tag": "0x03",
          "encoding": "LEB128 length + UTF-8 bytes"
        },
        "BYTES": {
          "id": 5,
          "lc_tag": "0x04",
          "encoding": "LEB128 length + raw bytes"
        },
        "ARRAY": {
          "id": 6,
          "lc_tag": "0x05/0x06",
          "encoding": "ARR_START + elements + ARR_END"
        },
        "OBJECT": {
          "id": 7,
          "lc_tag": "0x07/0x08",
          "encoding": "OBJ_START + contract_id + sorted_fields + OBJ_END"
        }
      },
      "field_notation": {
        "syntax": "@N",
        "description": "@N denotes zero-based field index N within a contract object.",
        "rule": "Fields MUST be encoded in ascending index order in LC-B.",
        "violation": "E_FIELD_ORDER"
      }
    },
    "4_contracts": {
      "description": "The canonical contract registry. Contract IDs are namespaced.",
      "reference": "See Section 6 in corpus/README_GITHUB.md for full contract specifications.",
      "core_contracts": {
        "1:HLXLiteValue": {
          "id": 1,
          "purpose": "Root value wrapper"
        },
        "2:HLXLiteField": {
          "id": 2,
          "purpose": "Object field descriptor"
        },
        "3:HLXLiteObject": {
          "id": 3,
          "purpose": "Typed object container"
        },
        "4:HLXLiteDocument": {
          "id": 4,
          "purpose": "Top-level document wrapper"
        },
        "5:ProvenanceLite": {
          "id": 5,
          "purpose": "Document metadata"
        }
      },
      "latent_contracts": {
        "800:LatentHandle": {
          "id": 800,
          "purpose": "Reference to collapsed value"
        },
        "801:LatentTable": {
          "id": 801,
          "purpose": "Handle storage table"
        },
        "820:LSOp": {
          "id": 820,
          "purpose": "Latent Space operation instruction"
        }
      },
      "policy": {
        "unknown_contracts": "ALLOWED - transport layer is agnostic",
        "validation_level": "STRUCTURAL_ONLY",
        "semantic_interpretation": "EXTERNAL (application layer)"
      }
    },
    "5_transliteration": {
      "description": "Bijective mapping between HLXL (ASCII) and HLX (Runic). Reference for full table.",
      "rule": "Strict 1:1 mapping. No exceptions. Transliteration is lossless.",
      "reference": "See corpus/README_GITHUB.md Section 'Glyph Reference' for complete table.",
      "key_mappings": {
        "⟠": "program",
        "◇": "block",
        "⊢": "let",
        "↩": "return",
        "⚳": "ls.collapse",
        "⚯": "ls.resolve",
        "▷": "|>",
        "⟁": "&h_"
      }
    }
  }
}