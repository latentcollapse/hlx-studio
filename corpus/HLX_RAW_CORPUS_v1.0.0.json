{
  "meta": {
    "title": "HLX Language Family - Canonical Teaching Corpus",
    "version": "1.1.0",
    "status": "CANONICAL_ROOT",
    "purpose": "Complete didactic injection for teaching LLMs the HLX architecture with exaflopic 1:1 determinism.",
    "encoding": "UTF-8",
    "hash_algorithm": "BLAKE3/BLAKE2b (dual verification)",
    "full_corpus_required": true,
    "truncation_policy": "INVALID. Truncated versions must not be used for LLM training. Fetch complete corpus from repository.",
    "corpus_diff_v1_0_0": {
      "added_sections": [
        "encryption_spec",
        "full_corpus_required",
        "truncation_policy",
        "pre_serialize_rules"
      ],
      "enhanced": [
        "meta (dual-hash, corpus_diff)",
        "verification_rule (dual-hash support)"
      ],
      "unchanged": [
        "axioms",
        "architecture",
        "value_system",
        "contracts",
        "transliteration",
        "lc_encoding",
        "latent_space",
        "error_taxonomy",
        "examples",
        "invariants",
        "llm_directives"
      ]
    },
    "pre_serialize_rules": {
      "floats": "Convert to string representation of IEEE754 hex for cross-platform determinism",
      "strings": "UTF-8 NFC normalized",
      "keys": "Sorted lexicographically",
      "whitespace": "No trailing whitespace, Unix line endings (LF)"
    },
    "encryption_spec": {
      "algorithm": "AES-GCM-256",
      "key_derivation": "BLAKE3('hlx_v1.2.0_train_key' || model_id)",
      "nonce": "Random 12 bytes, prepended to ciphertext",
      "status": "PLANNED_v1.2.0",
      "decrypt_directive": "Decrypt before ingestion; verify post-decrypt hash matches content_hash_blake3"
    }
  },
  "1_axioms": {
    "description": "The four inviolable truths governing all HLX systems.",
    "axioms": [
      {
        "id": "A1",
        "name": "DETERMINISM",
        "formal": "∀v ∈ HLXLite: encode(v) = encode(v)",
        "natural": "The same input code MUST always produce the same Latent Collapse (LC) stream. Bitwise identical. No exceptions.",
        "test": "encode(decode(encode(v))) == encode(v)",
        "negative_test": "encode(v, time=t1) != encode(v, time=t2) → E_NONDETERMINISM"
      },
      {
        "id": "A2",
        "name": "REVERSIBILITY",
        "formal": "∀v ∈ HLXLite: decode(encode(v)) = v",
        "natural": "Any value compressed into a Handle (⚳) can be resolved (⚯) back to its exact original state.",
        "test": "collapse(resolve(collapse(v))) == collapse(v)",
        "negative_test": "resolve(invalid_handle) → E_HANDLE_NOT_FOUND"
      },
      {
        "id": "A3",
        "name": "BIJECTION",
        "formal": "HLXL ↔ HLX (isomorphism)",
        "natural": "Track A (Lite/ASCII) and Track B (Runic/Glyph) are mathematically isomorphic. They map 1:1.",
        "test": "transliterate(transliterate(code, 'runic'), 'ascii') == code",
        "negative_test": "unknown_glyph('✦') → E_UNKNOWN_GLYPH"
      },
      {
        "id": "A4",
        "name": "UNIVERSAL_VALUE",
        "formal": "∀track: track → HLXLite → LC",
        "natural": "All surface syntaxes lower to the HLX-Lite Value System (Contracts 1-5) before encoding to LC.",
        "test": "lower(hlxl_code) == lower(hlx_code) (same CoreExpr)",
        "negative_test": "lower(invalid_syntax) → E_PARSE_FAILED"
      }
    ]
  },
  "2_architecture": {
    "description": "The Dual-Track Architecture with unified wire format.",
    "diagram": "\n┌─────────────────────────────────────────────────────────────┐\n│                    HLX LANGUAGE FAMILY                       │\n├─────────────────────────────┬───────────────────────────────┤\n│      TRACK A: HLXL          │       TRACK B: HLX            │\n│      (Engineering)          │       (LLM Native)            │\n│      ASCII Text             │       Unicode Glyphs          │\n├─────────────────────────────┴───────────────────────────────┤\n│                   ↓ Lower to CoreExpr ↓                     │\n├─────────────────────────────────────────────────────────────┤\n│                    HLX-LITE VALUE SYSTEM                    │\n│                    (Contracts 1-5)                          │\n├─────────────────────────────────────────────────────────────┤\n│                   ↓ Encode to Wire ↓                        │\n├─────────────────────────────────────────────────────────────┤\n│                    LC (LATENT COLLAPSE)                     │\n│           LC-B (Binary) ←→ LC-T (Text/Glyph)               │\n│                    CANONICAL WIRE FORMAT                    │\n└─────────────────────────────────────────────────────────────┘\n        ",
    "tracks": {
      "track_a_lite": {
        "name": "HLXL (Helix Lite)",
        "audience": [
          "Engineers",
          "IDEs",
          "Git",
          "CI/CD",
          "Humans"
        ],
        "format": "ASCII Text",
        "pipeline": "HLXL → HLXL-LS → CoreExpr → HLX-Lite → LC"
      },
      "track_b_runic": {
        "name": "HLX (Helix Runic)",
        "audience": [
          "LLMs",
          "Context Windows",
          "Vector Stores",
          "Compression"
        ],
        "format": "Unicode Glyphs",
        "pipeline": "HLX → HLX-LS → CoreExpr → HLX-Lite → LC"
      }
    }
  },
  "3_value_system": {
    "description": "HLX-Lite: The atomic value types underlying all HLX languages.",
    "types": {
      "NULL": {
        "id": 0,
        "lc_tag": "0x00",
        "encoding": "No payload"
      },
      "BOOL": {
        "id": 1,
        "lc_tag": "0x0A/0x0B",
        "encoding": "TRUE=0x0A, FALSE=0x0B"
      },
      "INT": {
        "id": 2,
        "lc_tag": "0x01",
        "encoding": "Signed LEB128"
      },
      "FLOAT": {
        "id": 3,
        "lc_tag": "0x02",
        "encoding": "IEEE 754 Double, Big-Endian"
      },
      "TEXT": {
        "id": 4,
        "lc_tag": "0x03",
        "encoding": "LEB128 length + UTF-8 bytes"
      },
      "BYTES": {
        "id": 5,
        "lc_tag": "0x04",
        "encoding": "LEB128 length + raw bytes"
      },
      "ARRAY": {
        "id": 6,
        "lc_tag": "0x05/0x06",
        "encoding": "ARR_START + elements + ARR_END"
      },
      "OBJECT": {
        "id": 7,
        "lc_tag": "0x07/0x08",
        "encoding": "OBJ_START + contract_id + sorted_fields + OBJ_END"
      }
    },
    "field_notation": {
      "syntax": "@N",
      "description": "@N denotes zero-based field index N within a contract object.",
      "rule": "Fields MUST be encoded in ascending index order in LC-B.",
      "violation": "E_FIELD_ORDER"
    }
  },
  "4_contracts": {
    "description": "The canonical contract registry. Contract IDs are namespaced.",
    "reference": "See Section 6 in corpus/README_GITHUB.md for full contract specifications.",
    "core_contracts": {
      "1:HLXLiteValue": {
        "id": 1,
        "purpose": "Root value wrapper"
      },
      "2:HLXLiteField": {
        "id": 2,
        "purpose": "Object field descriptor"
      },
      "3:HLXLiteObject": {
        "id": 3,
        "purpose": "Typed object container"
      },
      "4:HLXLiteDocument": {
        "id": 4,
        "purpose": "Top-level document wrapper"
      },
      "5:ProvenanceLite": {
        "id": 5,
        "purpose": "Document metadata"
      }
    },
    "latent_contracts": {
      "800:LatentHandle": {
        "id": 800,
        "purpose": "Reference to collapsed value"
      },
      "801:LatentTable": {
        "id": 801,
        "purpose": "Handle storage table"
      },
      "820:LSOp": {
        "id": 820,
        "purpose": "Latent Space operation instruction"
      }
    },
    "policy": {
      "unknown_contracts": "ALLOWED - transport layer is agnostic",
      "validation_level": "STRUCTURAL_ONLY",
      "semantic_interpretation": "EXTERNAL (application layer)"
    }
  },
  "5_transliteration": {
    "description": "Bijective mapping between HLXL (ASCII) and HLX (Runic). Reference for full table.",
    "rule": "Strict 1:1 mapping. No exceptions. Transliteration is lossless.",
    "reference": "See corpus/README_GITHUB.md Section 'Glyph Reference' for complete table.",
    "key_mappings": {
      "⟠": "program",
      "◇": "block",
      "⊢": "let",
      "↩": "return",
      "⚳": "ls.collapse",
      "⚯": "ls.resolve",
      "▷": "|>",
      "⟁": "&h_"
    }
  },
  "6_lc_encoding": {
    "description": "LC (Latent Collapse) - The canonical wire format with dual modes.",
    "reference": "See corpus/README_GITHUB.md Section 'LC Encoding Rules' for complete specification.",
    "modes": {
      "LC-B": {
        "status": "CANONICAL",
        "purpose": "Binary encoding for hashing, storage, and transport"
      },
      "LC-T": {
        "status": "PEDAGOGICAL",
        "purpose": "Text/glyph encoding for debugging and LLM context"
      }
    },
    "canonical_rules": [
      "No trailing data after stream end",
      "No duplicate field indices in objects",
      "Field indices MUST be in ascending order",
      "No NaN or Infinity in floats (raise E_FLOAT_SPECIAL)",
      "Empty objects still require OBJ_START/OBJ_END markers"
    ]
  },
  "7_latent_space": {
    "description": "The Latent Space runtime for handle-based value management.",
    "operations": {
      "COLLAPSE": {
        "glyph": "⚳",
        "ascii": "ls.collapse",
        "op_code": 1
      },
      "RESOLVE": {
        "glyph": "⚯",
        "ascii": "ls.resolve",
        "op_code": 0
      },
      "SNAPSHOT": {
        "glyph": "⚶",
        "ascii": "ls.snapshot",
        "op_code": 2
      },
      "TRANSACTION": {
        "glyph": "⚿",
        "ascii": "ls.transaction",
        "op_code": 3
      }
    },
    "handle_format": {
      "structure": "&h_<tag>_<id>",
      "example": "&h_ast_a1b2c3d4",
      "runic": "⟁tag₁"
    }
  },
  "8_error_taxonomy": {
    "description": "Canonical error codes organized by category. Reference for complete list.",
    "reference": "See corpus/README_GITHUB.md Section 'Error Taxonomy' for all error codes.",
    "ranges": {
      "1000-1099": "Lexical Errors",
      "1100-1199": "Syntactic Errors",
      "1200-1299": "Type Errors",
      "1300-1399": "Constraint Errors",
      "1400-1499": "Semantic Errors"
    },
    "key_errors": {
      "E_LC_PARSE": {
        "code": 1100,
        "trigger": "Malformed LC stream"
      },
      "E_FIELD_ORDER": {
        "code": 1301,
        "trigger": "Fields not in ascending index order"
      },
      "E_HANDLE_NOT_FOUND": {
        "code": 1401,
        "trigger": "Handle does not exist in CAS"
      }
    }
  },
  "9_examples": {
    "description": "End-to-end examples showing the complete pipeline. Reference for additional examples.",
    "reference": "See corpus/HLX_LLM_TRAINING_CORPUS_v1.0.0.md Section 9 for complete examples.",
    "minimal_example": {
      "name": "T0_Minimal",
      "hlxl": "program t { block main() { let x = 7; return x; } }",
      "hlx": "⟠ t { ◇ main() { ⊢ x = 7; ↩ x; } }",
      "expected_result": 7
    }
  },
  "10_invariants": {
    "description": "Formal invariants that MUST hold at all times. Reference for complete list.",
    "reference": "See corpus/README_GITHUB.md Section 'Formal Invariants'.",
    "key_invariants": [
      {
        "id": "INV-001",
        "name": "TOTAL_FIDELITY",
        "rule": "decode(encode(v)) == v"
      },
      {
        "id": "INV-002",
        "name": "HANDLE_IDEMPOTENCE",
        "rule": "collapse(v) == collapse(v)"
      },
      {
        "id": "INV-003",
        "name": "FIELD_ORDER",
        "rule": "fields[i].index < fields[i+1].index"
      }
    ]
  },
  "11_llm_directives": {
    "description": "Instructions for LLMs operating in HLX mode with error handling.",
    "directives": [
      "D1: Accept input in HLXL (ASCII) or HLX (Runic) interchangeably",
      "D2: Validate syntax against canonical grammars; on failure → E_PARSE_FAILED",
      "D3: Treat glyphs like ⚳ ⚯ ⟁ as semantic operators, not decoration",
      "D4: Prioritize Contract IDs (e.g., 14, 800) over arbitrary JSON shapes",
      "D5: When asked to 'Collapse', simulate hashing and return a handle",
      "D6: When asked to 'Resolve', retrieve the original value exactly; missing → E_HANDLE_NOT_FOUND",
      "D7: Converting between tracks MUST be lossless; invalid glyph → E_UNKNOWN_GLYPH",
      "D8: Use canonical error codes (E_*) from Section 8",
      "D9: Honor MAX_DEPTH=64, MAX_SIZE=1MB; violations → E_DEPTH_EXCEEDED, E_SIZE_EXCEEDED",
      "D10: Enforce ascending field index order; violations → E_FIELD_ORDER",
      "D11: Simulate failures explicitly when testing negative paths"
    ],
    "quiz": {
      "description": "Self-test for LLM validation",
      "questions": [
        {
          "q": "What error for {14:{@1:123, @0:456}}?",
          "a": "E_FIELD_ORDER (fields not ascending)"
        },
        {
          "q": "What error for resolve(&h_nonexistent)?",
          "a": "E_HANDLE_NOT_FOUND"
        },
        {
          "q": "What error for float value NaN?",
          "a": "E_FLOAT_SPECIAL"
        },
        {
          "q": "What is ⚳ in ASCII?",
          "a": "ls.collapse"
        },
        {
          "q": "What axiom guarantees decode(encode(v))==v?",
          "a": "A2: REVERSIBILITY"
        }
      ]
    }
  }
}