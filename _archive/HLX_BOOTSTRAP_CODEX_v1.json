{
  "meta": {
    "title": "HLX Bootstrap Codex",
    "version": "1.0.0",
    "status": "CANONICAL_ROOT",
    "hash": "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
    "purpose": "Didactic injection of the HLX Language Family into LLM context."
  },
  "1_introduction": {
    "definition": "HLX (Helix) is a deterministic, reversible software architecture designed for Large Language Models. It treats the LLM not as a text generator, but as a state machine processing latent operations.",
    "axioms": [
      "A1: DETERMINISM. The same input code must always produce the same Latent Collapse (LC) stream.",
      "A2: REVERSIBILITY. Any value compressed into a Handle (âš³) can be resolved back (âš¯) to its exact original state.",
      "A3: BIJECTION. Track A (Lite) and Track B (Runic) are mathematically isomorphic. They map 1:1."
    ]
  },
  "2_architecture": {
    "description": "The HLX family consists of two parallel tracks that converge on a single value system (HLX-Lite) and wire format (LC).",
    "structure": {
      "track_a_lite": {
        "audience": "Engineers, Tooling, IDEs",
        "format": "ASCII Text (HLXL)",
        "pipeline": "HLXL (Source) -> HLXL-LS (Latent Ops) -> HLX-Lite (Value) -> LC (Stream)"
      },
      "track_b_runic": {
        "audience": "LLMs, Context Windows, High-Density Storage",
        "format": "Unicode Glyphs (HLX)",
        "pipeline": "HLX (Source) -> HLX-LS (Latent Ops) -> HLX-Lite (Value) -> LC (Stream)"
      },
      "convergence": "Both tracks lower to the same Abstract Syntax Tree (CoreExpr) and manipulate the same Value Objects (HLX-Lite)."
    }
  },
  "3_foundation_hlx_lite": {
    "description": "The atomic value system underlying all HLX languages. It defines HOW data is structured, regardless of syntax.",
    "contracts": {
      "1:HLXLiteValue": {
        "id": 1,
        "fields": {
          "kind": "ENUM (NULL=0, BOOL=1, INT=2, FLOAT=3, TEXT=4, BYTES=5, ARRAY=6, OBJECT=7)",
          "payload": "The actual data corresponding to the kind."
        }
      },
      "2:HLXLiteField": {
        "id": 2,
        "fields": {
          "index": "INT (Sorted field index)",
          "name": "TEXT (Original key name)",
          "value": "HLXLiteValue (Recursive)"
        }
      },
      "3:HLXLiteObject": {
        "id": 3,
        "fields": {
          "contract_id": "INT (The schema ID, e.g., 14)",
          "fields": "ARRAY[HLXLiteField] (Must be sorted by index)"
        }
      },
      "4:HLXLiteDocument": {
        "id": 4,
        "fields": {
          "root": "HLXLiteValue",
          "provenance": "ProvenanceLite"
        }
      },
      "5:ProvenanceLite": {
        "id": 5,
        "fields": {
          "profile": "TEXT (e.g., 'hlx-v1')",
          "timestamp": "TEXT (ISO8601)",
          "engine_id": "TEXT",
          "origin": "TEXT"
        }
      }
    }
  },
  "4_track_a_hlxl": {
    "name": "Helix Lite (HLXL)",
    "description": "The ASCII surface language. Optimized for human readability and traditional tooling.",
    "syntax_map": {
      "program_decl": "program <name> { ... }",
      "block_decl": "block <name>(<params>) { ... }",
      "variable_decl": "let <name> = <expr>;",
      "frame_local": "local <name> = <expr>;",
      "return_stmt": "return <expr>;",
      "control_if": "if (<cond>) { ... } else { ... }",
      "control_while": "while (<cond>) { ... }",
      "latent_op": "ls.<op> <args>",
      "pipeline": "|>"
    },
    "example": "program demo { block main() { let x = 10; return x * 2; } }"
  },
  "5_track_b_hlx": {
    "name": "Helix Runic (HLX)",
    "description": "The Unicode surface language. Optimized for LLM token efficiency and semantic density.",
    "glyph_map": {
      "âŸ ": "program (Structure)",
      "â—‡": "block (Structure)",
      "âŠ¢": "let (State)",
      "âŠ¡": "local (Frame)",
      "â†©": "return (Flow)",
      "â“": "if (Flow)",
      "â—": "else (Flow)",
      "âŸ³": "while (Flow)",
      "âŸ²": "for (Flow)",
      "âš³": "ls.collapse (Latent)",
      "âš¯": "ls.resolve (Latent)",
      "âš¶": "ls.snapshot (Latent)",
      "âš¿": "ls.transaction (Latent)",
      "â–·": "|> (Pipeline)"
    },
    "transliteration_rules": "Strict 1:1 mapping. 'âŸ ' ALWAYS equals 'program'. 'âŠ¢' ALWAYS equals 'let'. No exceptions.",
    "example": "âŸ  demo { â—‡ main() { âŠ¢ x = 10; â†© x * 2; } }"
  },
  "6_latent_space": {
    "description": "The runtime environment where values are compressed into Handles.",
    "contracts": {
      "800:LatentHandle": {
        "id": 800,
        "fields": {
          "id": "TEXT (Unique ID)",
          "tag": "TEXT (Human readable hint)",
          "fingerprint": "BYTES (Content Hash)"
        }
      },
      "801:LatentTable": {
        "id": 801,
        "fields": {
          "table_id": "TEXT",
          "entries": "ARRAY[Entry]"
        }
      },
      "820:LSOp": {
        "id": 820,
        "description": "The canonical instruction for Latent Operations.",
        "fields": {
          "op_code": "INT (0=RESOLVE, 1=COLLAPSE, 2=SNAPSHOT)",
          "table": "TEXT (Target Table ID)",
          "handle": "TEXT (Target Handle)",
          "value": "HLXLiteValue (Input for Collapse)"
        }
      }
    },
    "handle_syntax": {
      "track_a": "&h_<tag>_<id> (e.g., &h_ast_1)",
      "track_b": "âŸ<tag><subscript_id> (e.g., âŸastâ‚)"
    }
  },
  "7_latent_collapse": {
    "name": "LC (Latent Collapse)",
    "description": "The universal wire format. A stream-based binary encoding of HLX-Lite values.",
    "markers": {
      "ğŸœŠ": "OBJECT_START (Followed by Contract ID)",
      "ğŸœ": "FIELD_START (Followed by Index)",
      "ğŸœ‚": "OBJECT_END",
      "ğŸœƒ": "ARRAY_START",
      "ğŸœ„": "ARRAY_END",
      "ğŸœ‡": "HANDLE_REF",
      "ğŸœ‹": "STREAM_END"
    },
    "stream_logic": "LC is a depth-first traversal of the HLX-Lite value tree. It is positional and schema-agnostic.",
    "example_stream": "ğŸœŠ14ğŸœ0123ğŸœ‚ (Encodes {14:{@0:123}})"
  },
  "8_rosetta_stone": {
    "description": "The same logic expressed across all layers.",
    "scenario": "Collapse a value {14:{@0:123}} and return the handle.",
    "layer_1_hlxl": "let h = ls.collapse {14:{@0:123}};",
    "layer_2_hlx": "âŠ¢ h = âš³ {14:{@0:123}};",
    "layer_3_core_expr": "{ \"kind\": \"LS_OP\", \"op\": \"COLLAPSE\", \"val\": { \"14\": { \"@0\": 123 } } }",
    "layer_4_lc_wire": "ğŸœŠ820ğŸœ1 1 ğŸœ3 ğŸœŠ14ğŸœ0 123 ğŸœ‚ ğŸœ‚ (LSOp encoded)"
  },
  "9_directives": {
    "instruction": "When operating in HLX Mode:",
    "rules": [
      "1. You MUST accept input in either HLXL (ASCII) or HLX (Runic).",
      "2. You MUST internally validate the syntax against the Grammars defined in Sections 4 & 5.",
      "3. You MUST treat glyphs like 'âš³' as semantic operators, not decoration.",
      "4. You MUST prioritize HLX-Lite Contract IDs (e.g., 14, 800) over arbitrary JSON shapes.",
      "5. When asked to 'Collapse', you MUST simulate the hashing and storage of the value.",
      "6. When asked to 'Resolve', you MUST retrieve the original value bit-for-bit."
    ]
  }
}